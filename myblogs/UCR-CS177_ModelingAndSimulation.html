<!DOCTYPE html>
<html>
	<head>
		<title>My CS177 Notes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="../w3.css">
	</head>

	<body>
		<div class="w3-container w3-black w3-center">
			<h1>UCR CS177 Modeling And Simulation</h1>
		</div>

		<div class="w3-container w3-black">
			<h3>Lecture 1: Introduction</h3>
			<p>This course is about modeling via simulation. We may have learned to solve a real world problem by constructing a math model. You may also know about 3D modeling. But why do we need modeling? There are a few reasons:<p>
			<ol>
				<li>Design Evaluation: Building a physical and complex system is time-consuming and expensive. So we should determine whether a design works before building it rather than the other way round.</li>
				<li>Comparing Numerous Alternatives: Oftentimes there are a lot of possible strategies/methods to solve a problem/complete a task, we want to know which option is the best without trying all the possiblities.</li>
				<li>Emulate Dangerous or Impossible Situations: There are scenarios that are too dangerous to try (e.g. testing a war strategy, experimenting a possibly unstable chemical reactions, test safety systems in a nuclear reactor) or impossible to examine in real life (e.g. design a good defense for Quidditch). We need to construct a model to emulate this type of situations.</li>
				<li>Change Time Scales: On one hand, some events happen extremely fast (e.g. a car crash, a big bang). We want to slow them down to figure out what happened and why it happened during this entire event. On the other hand, some events happen relatively really slow (e.g. global warming, epidemics, extinction of endangered species). We would like to construct a model to see how things would go if the current situation persists (, which is kind of similar to the next reason).</li>
				<li>Predict the Future: We want to use the past experience to predict what is likely to happen in the future so we can prepare for it (e.g. weather forcasting) or make a profit (predicting stock prices, do high frequency trading based on price predictions a few milliseconds into the future).</li>
				<li>Cost Savings: It is very difficult to learn to fly aircrafts and newbies may make a lot of mistakes when learning, which may cause catastrophic outcomes. It is better we build a model aircraft and let newbies begin from there. Another example would be practice race driving. It may be costly to practice when prepping for a competition (e.g. Pikes Peak Internation Hill Climb, Formula One, WRC, etc) because you need to customize your race car often and it may not be possible to practice at the real course whenever you want. It is better we build a model, especially a simulation model so that we can not only practice but also try to see which customizations work before actually making the change.</li>
			</ol>

			<p>It sounds to me that modeling is good enough for problem solving already. Why do we want to blend in with simulation? Here are a few reasons why we would like to use simulation with modeling:</p>
			<ol>
				<li>Evaluate complex models: models are good when you are considering only a handful of objects, but if the number of objects increases and these objects can affect each other, then it becomes extremely difficult to compute the exact solution because you are actually not 100% what is going to happen and what the impact will be to subsequent events (e.g. Dumping a ball onto the ground vs. dumping a full bucket of balls onto the ground. When you dump a full bucket of balls onto the ground, balls may collide with each other, the change of directions may cause new colides.). Simulation will be very helpful here. Essentially we are trying to let everything happen to see how well the model is working intead of mathematically proving the model is working because the model is too complicated.</li>
				<li>Hypothese testing: there are cases where the real system may not be available, we would like to predict effects of the change we would like to make on the current system (e.g. changing workload, operating policies).</li>
				<li>Validate analytical models: Analytical models require many simplifying assumptions. We can use simulation to test how sensitive the results are to each of those assumptions.</li>
				<li>Control extraneous factors: Simluation is useful when you want to compare your models on the exact same situation and see how each of them works. An example is record the workload from one day in a hospital emergency ward and play it back exactly for each scheduling policies or job assignments you want to compare.</li>
			</ol>

			<p>Hmm... So we can use simulation to validate/test the model we created. Or we can build a simulation model to solve problems. But are there any drawbacks using simulation? There are and here they are:</p>
			<ol>
				<li>Simulation programs can be expensive, time-consuming to develop and run.</li>
				<li>Programs can be buggy.</li>
				<li>The simulation result is just an estimate. The solution it provides is not exact, meaning that it can change if you re-run the simulation although it may still fall into the pattern you find out. Not seeing something in your simulation does not mean that something cannot happen. It might be a black swan.</li>
			</ol>

			<p>After knowing the pros and cons about simulation. We can actually dive into simulation modeling and see what people have done using simulation. You may ask why we do not seem to care about using simulation to validate models. That answer is to validate the model via simulation, we are also constructing a simulation model, but catered to the problem of validating the math model we created.</p>

			<p>There are four types of simulation models if we consider the following two factors: (1)Are there factors of randomness? and (2)Is time a factor? Based on answers of the above questions we can categorize the model into:</p>
			<ol>
				<li>Deterministic-Static Simulation: no randomness, not time-variant. Example: floating-point arithmetic (used to simulate real number arithmetic on computing systems. Since they are finite they introduce errors. You need to make sure that floating-point arithmetics have the desire precision you want when using it); scale models (an example is scaling down the galaxy to a size that we can display it in a museum. Because the actual galaxy is too big for a museum so we created a simulated galaxy).</li>
				<li>Deterministic-Dynamic Simulation: no randomness, time-variant. Example: computational fluid dynamics; finite-element methods (use numerical methods to solve differential equations set, the answer simulates liquid, gas, or structures)</li>
				<li>Stochastic-Static Simluation: has randomness, not time-variant. Example: Monte Carlo methods (an example using this method is determing the probability of showing heads in a coin flip. We try flipping a coin for N times and record the number of appearance of heads H, then (H/N) will be the probability of the showing heads in a coin flip. The larger the N is, the more accurate the result will be).</li>
				<li>Stochastic-Dynamic Simulation: has randomness, time-variant. Example: Brownian motion; Discret-event stochastic models(random walk). This course will focus on discret-event stochastic models (think of it as a Marcov chain).</li>
			</ol>

			<p>An example: The Trained-Flea Experiment. A trained flea stands on a (2n+1) * (2n+1) chess board (this enviromnemt setting is called system). Initially he stands on the middle square (this is called the initial state). Each time a bell rings, he hops randomly to 1 to 8 adjacent cells (this is called an event). The problem is to find the average number of hops before he falls off the board (this is the experiment, or what we are going to find out using simulation). To simulate the problem is simple, one can write some code to generate a possible path and record the path length. Run this program multiple times and then you will get a estimate of the average path length.</p>

			<p>We can actually compare the math modeling and simulation modeling in this problem here by solving this problem. We can first solve a simpler version of this problem: The Trained-Flea Experiment on 3x3 chess board. Because the board is symmetric and that the flea's hopping action is memoryless, meaning that it can revisit a square, we can categorize the squares into three types: corner squares, mid-edge squares, and center. And then we solve this problem iteratively using dynamic programming. We can convert this problem to a finite horizon model with a simple "trick": suppose we ranout of food, so the flea will starve (to death) after his i-th hop. Thus, let a_i, b_i, c_i be the respective average of hops until he falls off the board (or dies) - starting from each square class. We can quickly derive that a_1 == b_1 == c_1 == 1 because the flea is on the board , so he needs at least one hop to fall of the board, and his food is only enough for him to make one hop only. When i is greater than 1, there are following conditions:</p>
			<ol>
				<li>If the flea is initially standing on a corner square, then a_i = (5/8) * 1 + (2/8) * (1+b_i-1) + (1/8) * (1+c_i-1) (i > 1)</li>
				<li>If the flea is initially standing on a mid-edge square, then b_i = (3/8) * 1 + (2/8) * (1+a_i-1) + (2/8) * (1+b_i-1) + (1/8) * (1+c_i-1)</li>
				<li>If the flea is initially standing on a center square, then c_i = (4/8) * (1+a_i-1) + (4/8) * (1+b_i-1)</li>
			</ol>

			<p>We can iterate these equations to eliminate the starvation "trick", the solution is the limit of c_i as i approaches positive infinity. When i approaches positive infinity, then i ~= i - 1, so we can throw away the subscripts and get the following three equations:</p>
			<ul>
				<li>a = (5/8) * 1 + (2/8) * (1+b) + (1/8) * (1+c)</li>
				<li>b = (3/8) * 1 + (2/8) * (1+a) + (2/8) * (1+b) + (1/8) * (1+c)</li>
				<li>c = (4/8) * (1+a) + (4/8) * (1+b)</li>
			</ul>
			<p>Solve the equations using Matlab is a = 2.0571, b = 2.5714, c = 3.3143. And we can expand the method to get a solution for a (2n+1) * (2n+1) chess board.</p>

			<p>Getting the exact solution is easier/faster/cheaper than writing a program to generate large numbers of sample paths. But if you want to add extra elements/restraints (e.g. a flew will not return to a visited square, a flew never choose the same direction twice in a row, or the board is not a square, or we have multiple fleas on the board, etc) to the model, it may be difficult to come up with a sleek solution like what we just did because we may not be able to apply the same techinque we used when a new constraint is added. But we are able to handle these changes when programming the simulation program. This actually gives an edge to the simulation model.</p>
		</div><br><br>

		<div class="w3-container w3-black">
			<h3>Lecture 2: Constructing a Model</h3>
			<p>Here are some steps we should take when constructing a simulation model:</p>
			<ol>
				<li>Formulate the problem and plan the study: figure out what you want to do with the simulation model you want to build (e.g. compare different alternatives, evaluate a strategy in a simulated environment);</li>
				<li>Collect data, define a model: here we need to follow the KISS principle: Keep It Simple Stupid;</li>
				<li>Test for validity: after coming up with a simulation model, we need to determine whether it captures the key features of the target system we want to simulate. We can do this by describing our model to domain experts, user, and other stake-holders;</li>
				<li>Construct the program and "verify" its correct operation: code your simulation model, and check: if your random number generator works correctly, if each random variable follows its chosen probability distribution, if each model component does what it supposed to, and if the "infrastructure" code in your model works fine;</li>
				<li>Make pilot runs and validate: make sure your simulation model works as expected. Test your model with boundary cases, test if your model can reproduce the behavior of an existing system with known parameter settings. If no, then go back to step 2 to collect more data snd refine the model. If yes, you can start your experiment;</li>
				<li>Design the experiment: there are a few things to keep in mind. You need to decide on an acceptable level of confidence in your conclusions. And you need to think about how to reduce variance in your models.</li>
				<li>Make production runs</li>
				<li>Analyze the outputs: we need to remember that each output is determined by a bunch of randoms numbers, which means that the result is just an estimate. We must provide confidence intervals for each output value.</li>
				<li>Document the process and implement the conclusions</li>
			</ol>

			<p>A simulation program should consist of the following components:</p>
			<ul>
				<li>System State: system state should include the following things:
						<ul>
							<li>Entities (customers, resources, etc): 
								<ul>
										<li>They have attributes such as location, arrival time, service demand. We can define an entity using struct or class in C++</li>
										<li>They may belong to groupings of similar entities (e.g. waiting lines). We can use a vector or list in C++ to capture such groupings.</li>
										<li>Different entity types may be related (e.g. server and customer). We may use pointers or a dictionary to store such mappings.</li>
								</ul>
							</li>
							<li>Stochastic variables: they are used to represent tntity attributes, event times, etc</li>
							<li>Strategies: they are used when comparing different versions of a model, represented by flag variables, separate functions</li>
						</ul>
				</li>
				<li>Simulation clock</li>
				<li>Events: an "atomic action" that updates the system states. Note that carrying out one event often triggers the creation of other events (e.g. each arrival event schedules the next arrival event, a start service event schedules the same customer's end serice event)</li>
				<li>Event Scheduling: scheduling determines how the system states in the model evolves over time. There are two ways to schedule events: time-driven and event-driven scheduling. As their names entail, time-driven scheduling loops through time and look for events that happen during each step, whereas event-driven scheduling loops uses a priority queue to store the events and go through them one by one, advancing time accordingly. Note that Time-driven scheduling is only useful when the timing of the events are roughly evenly spaced because if we choose a step that is too small we increase the program runtime by increasing the total number of iterations. If we choose a step that is too large we may end up artificially creating simultaneous sequential events which may not make sense.</li>
				<li>Program instrumentation: Data structures that record information about the simulation model. This is external to the actual model. Speaking of measurements, here are some of the items that you may be interested in tracking:
					<ul>
						<li>See if a specific events occur (dam bursts? hospital has no beds?)</li>
						<li>Count occurrences</li>
						<li>Find minimum or maximum valus</li>
						<li>Properties of attribute values (e.g. what fraction of customers wait longer 10 minutes; what is the 90th percentile of customer wait)</li>
					</ul>
				</li>
				<li>Report generator: you should have the same piece of code to produce "snap shots" during program execution, the code should be able to compute, tabulate and summarize the instrumentaion. The reason for "snap shots" is that we need to see the long-term trends of the output to find out if the system is actually behaving randomly.</li>
			</ul>

			<p>When doing measurements in a simulation model, there are two types of average we may need to compute: time average and population avarage. Time avarage is a weighted average with weight being the lifetime of a specific value. Whereas population average is a weighted average based on population. Here is a very interesting example about time-average and population-average:</p>
			<ul>
				<li>Suppose lightbulbs suffer from infant mortality problems.There is some kind of manufacturing defect that causes 75% of the lightbulbs to fail after 1000 hours; while the remaining 25% will last for 37000 hours before failure. The population average shows that the average lifetime for a lightbulb is 10000 hours. With population-average you may think that it is acceptable, but when you randomly pick a lightbulb, 75% percent you end up having a defected one. You actually need to buy at least eight lightbulbs at a time to guarantine a approx. 90% chance that you at least buy one normal lightbulb. How can I buy less lightbulbs but maintain the chance that I have a normal lightbulb?</li>
				<li>To do so, we need to use an extra equipment: the in-store lightbulb display that is used to demonstrate different style of lightbulb's color temperature and brightness. You should be able to find such display in Home Depot. The purchasing algorithm works as follows: 1) Find a box containing a new bulb of the desired style; 2) Swap the new bulb with the coresponding display sample; 3) Purchase the display sample and take it home. How does this in-store display help? We can demonstrate it using time-average.</li>
				<li>Suppose at time 0, a new sample is placed into the display. Once a sample is installed, its residual lifetime drops to zero at a slope of -1. Each burnt-out bulb is replaced immediately with a new sample so the lightbulb at the display is always on. Suppose I visit Home Depot at a random time, since a good bulb occupies 37 times as much time as a defective bulb, that means more likely the lightbulb at the display is a normal bulb. In fact, even though there are 3 times as much defective bulbs than normal bulbs, we still end up a probability of (0.25 * 37000) / (0.25 * 37000 + 0.75 * 1000) = 0.925. But because I come in at a random time, my display sample will be mid way through its life on average. The average residual lifetime for my display sample is: 0.075 * (1000/2) + 0.925 * (37000/2) = 17150 hours, much better than the expected average.</li>
				<li>A major drawback of this algorithm is that it only works for purchasing one bulb. If you want another bulb, then you may try going to another store, or wait 1000+ hours and return to the same store to try again (and hope nobody else tried your Purchasing Algorithm during that time).</li>
			</ul>

			<p>As for population average, there is one type of data we would like to know: the average number of customers in the system at any time. To get this number, one may need to do a scan over the each unit of time to compute the average. But there is a much quicker way to find out this number, if we know the average arrival rate of customers to the system and the average time in system for customers. This is Little's Law: average number of customers in the system = average time in system for customers * the average arrival rate of customers to the system.</p>

			<p>A concrete example is <a href="../supplements/UCR-CS177_GasStationSimulationModel.cpp" target="_blank">the gas station example</a>.</p>
		</div><br><br>

		<div class="w3-container w3-black">
			<h3>Lecture 3, 4, 5: CSIM Programming</h3>
			<p>This course teaches you how to use a programming package called CSIM from <a href="https://www.mesquite.com/" target="_blank">Mesquite Software</a>.</p>

			<p>I think it is better to use examples to learn the components of CSIM. Here are some example programs of CSIM:</p>
			<ul>
				<li>A compile script provided by the course instructor Professor Mart Molle. Replace the "$*" with your program: /usr/bin/g++ -DCPP -DGPP -I/usr/csshare/pkgs/csim_cpp-19.0/lib -m32 $* /usr/csshare/pkgs/csim_cpp-19.0/lib/csim.cpp.a -lm </li>
				<li><a href="../supplements/UCR-CS177_CSIMHelloWorld.cpp" target="_blank">A "Hello World" program</a></li>
				<li><a href="../supplements/UCR-CS177_GasStationCSIM.cpp" target="_blank">The gas station example rewritten in CSIM</a></li>
				<li><a href="../supplements/UCR0CS177_AirportShuttleSimV1.cpp" target="_blank">An airport shuttle system simulation (one Bus, one terminal and one carlot)</a></li>
				<li><a href="../supplements/UCR0CS177_AirportShuttleSimV2.cpp" target="_blank">Airport shuttle system simulation version 2 (extends the previous model with  multiple terminals)</a></li>
				<li><a href="../supplements/UCR0CS177_AirportShuttleSimV3.cpp" target="_blank">Airport shuttle system simulation version 3 (extends the version 2 with multiple buses and a sensible strategy to dispatch buses so as to avoid the scenario that one passenger wakes up the entire crew with more than one buses resting)</a></li>
			</ul>
		</div><br><br>

		<div class="w3-container w3-black">
			<h3>Lecture 6: Review of Probability and Statistics</h3>
			<p>Probability: a numeric value between 0 and 1 representing how likely an event is going to happen. Having 0 probability means the result is impossible whereas having 1 probability means the result is inevitable. We can determine the probability of an event by two methods:</p>
			<ul>
				<li>Experimental method: essentially a Monte-Carlo method which conduct many repitions of the experiment and report the proportion that match the chosen result.</li>
				<li>Non-Experimental method: list all possible outcomes for the experiment, and assgin each outcome a (most likely equal) probability. Then we define the event to be a subset of those outcomes and sum probabilities of the outcomes included in the defined event.</li>
			</ul>
			<p>For an event, we can assign each outcome of this event a value to reflect the result triggered by the event outcome. We use a <b>random variable (r.v.)</b> to store such values. An r.v. can be of the following two types:</p>
			<ul>
				<li>Discrete r.v.: Can take only a finite number of distinct values. We use a probability mass function (pmf) to denote the probability of the appearance of each possible value. Note that each function value is greater than or equal to 0 and less than or equal to 1. The sum of every indivial value of this pmf is exactly 1.</li>
				<li>Continuous r.v.: Can take any real value within some range. In this case, there is an infinite number of possible values so the probability of the apperance of each possible value is 0. But the probability of a value falling in a certain range may not be 0 so we actually focus on finding out this type of probability. This type of probability can be visualized if we can plot the entire valid range of values. On the chart, the probability of a certain range of values is actually how much the area determined by this range of numbers and the axis overlaps with the area determined by the valid range of numbers and the axis. We use integration to compute these areas. So the probability is denoted via the integral of the random variable's probability density function (pdf) f(x). If x is outside of the event's valid range, then f(x) = 0, otherwise f(x) is greater than or equal to 0 (f(x) is NOT A PROBABILITY and there is no hard upper limit for f(x)). The intergral of f(x)dx over its entire valid range is 1.</li>
			</ul>
			<p>Since we focus on different things when dealing with each type of random variables. Mathematicians came up with a solution to unify the focus by introducing a cumulative probability distribution function (PDF) F(x). F(x) = P(X less than or equal to x) so now everything is about how much the area determined by (X less than or equal to x) and the axis overlaps with the entire valid range of values and the axis. By convention, pdf is f() and PDF is F(); f_X() means pdf for r.v. X and F_X means PDF for r.v. X.</p>
			<p>Most systems we care about contain more than one random variables, so we need to consider a joint distribution of all random variables: F_{X1, X2, ..., Xn}(x1, x2, ..., xn) = P(X1 less than or equal to x1, X2 less than or equal to x2, ..., Xn less than or equal to xn). However, we know very little about the properties of the joint distribution in general. And we actually focus more on the marginal distribution of one of the variables Xj by using repeated integration from negative infinity and positive infinity by every variable except Xj to find F_Xj(xj).</p>
			<p>There is an easier way to find the marginal probability or join probability. If the random variables X1, X2, ..., Xn are mutually independent, then the joint PDF factors into the product of their individual marginal PDFs. One thing to point out is that Xi and Xj do not have causal relationship does not mean that Xi and Xj are independent.</p>
			<p>For a random variable X, we can compute the expected value/mean E[X] (or mu_X) and the variance of the variable Var(X):</p>
			<ul>
				<li>E[X] = x1*f1 + x2*f2 + ... + xn*fn if X is discrete.</li>
				<li>E[X] = integral of x*f(x)dx between a and b if X is continuous ranging from a to b.</li>
				<li>E[g(X)] = g(x1)*f1 + g(x2)*f2 + ... + g(xn)*fn if X is discrete.</li>
				<li>E[g(X)] = integral of g(x)f(x)dx between a and b if X is continuous ranging from a to b.</li>
				<li>E[a*g(X) + b*h(X)] = a * E(g(X)] + b * E([h(X)]</li>
				<li>Var(X) = E[(X - E[X])**2] = E[X**2] - E[X]**2 if we expand the former formula.</li>
				<li>Standard deviation (denoted as sigma) of r.v. is the square root of its variance. The reason to introduce the standard deviation is to make it comparable with the r.v.</li>
				<li>If we have random variables Xi and Xj, we can compute their convariance Cij = E[(Xi - E[Xi]) * (Xj - E[Xj])]. If Cij > 0 then Xi and Xj are positively correlated; if Cij = 0 then Xi and Xj are uncorrelated; if Cij < 0 then Xj and Xj are negatively correlated.</li>
				<li>Cij is not directly comparable with Xi or Xj. To make things comparable, we introduce Correlation cij = Cij / (sigma_i * sigma_j) = Cij / (E[Xi] * E[Xj]). The value is never outside the interval -1(opposite) and +1 (identical).</li>
			</ul>
			<p>You may wonder how probability theory helps in sumulation models. When a simulation model runs, we can set up checkpoints at different time to record the state of our model. If we repeat the experiment multiple times we get multiple observations and study the states. This process is called a stochastic process. Running a stochastic process should end up having a collection of r.v.s, X_t1, X_t2, ... with:</p>
			<ul>
				<li>A common sample space: each r.v. must take its values from the same set of choices.</li>
				<li>Indexed by time.</li>
			</ul>
			<p>If X_ti and X_tj are mutually independent, then the process is memoryless (Monte-Carlo Method, independent and identically distributed (i.i.d.) r.v.s). If otherwise then the process has memory, which means X_ti may influence X_tj if ti is less than tj (Markov Chain). For the latter, we may end up having an equilibrium state. Please note that X_t1, X_t2, ... may have different distribution that can still produce a common sample space. If  for each r.v.s in a random the process the expected value is the same regardless of their distribution, then the process is stationary. If the covariance between r.v.s are the same, then the process is covariance stationary.</p>
		</div><br><br>

		<div class="w3-container w3-black">
			<h3>Lecture 7: Confidence Intervals</h3>
			<p>In the previous lecture we talked about stochastic processes. Let's consider the a stochastic process with n i.i.d.r.v.s X1, X2, ..., Xn. The distribution of Xi has a finite theoratic mean mu and a finite theoratic variace sigma**2. We are not sure about the value of neither mu nor sigma, and we would like to run this stochastic process to find estimates of mu and sigma.</p>
			<p>After running the process, we obtain an observation for each r.v. x1, x2, ..., xn. To find the estimate of mu, we simply compute the arithmetic average of these n observations. Denote this value as avg(Xi, n) = sum(xi, n)/n where xi is an observation value of Xi. To find the estimate of sigma**2, instead of using avg((Xi - avg(Xi, n))**2, n) = sum((xi - sum(xi, n)/n)**2, n)/n, we use sum((xi - sum(xi, n)/n)**2, n)/(n - 1) to estimate the sigma**2. Doing this we will have E[sum((xi - sum(xi, n)/n)**2, n)/(n - 1)] = sum((E[Xi] - sum(E[Xi], n)/n)**2, n)/(n - 1) = sigma**2, making it an unbiased estimate. The course instructor has his perspective. When n = 1, sigma**2 = 0. This is correct because it tells you that variability is impossible with only one outcome. When n = 1, your variance estimate gives you a zero divide exception, which tells you that you cannot observe variability with one sample.</p>
			<p>One thing I would like to point out is that repeat a stochastic process with one random variable X1 n times is equivalent to running a stochastic process n i.i.d.r.v.s X1, X2, ..., Xn. The latter is formally used in textbooks but it is essentially the same thing as the former in my opinion.</p>
			<p>One way or another, when n approaches positive infinity, your sample mean approaches mu. Formally, that means P(limit(n->+inifinity, avg(X, n))) = 1 for any distribution X with n i.i.d. samples (be it an observation of X1, X2, ..., Xn or n observations of X1). This is the Strong Law of Large Numbers.</p>
		</div><br><br>

		<div class="w3-container w3-black w3-center">
			<p>you can contact me via e-mail</p>
		</div>
	</body>
</html>
