<!DOCTYPE html>
<html>
	<head>
		<title>My CS177 Notes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="../w3.css">
	</head>

	<body>
		<div class="w3-container w3-black w3-center">
			<h1>UCR CS177 Modeling And Simulation</h1>
		</div>

		<div class="w3-container w3-black">
			<h3>Lecture 1: Introduction</h3>
			<p>This course is about modeling via simulation. We may have learned to solve a real world problem by constructing a math model. You may also know about 3D modeling. But why do we need modeling? There are a few reasons:<p>
			<ol>
				<li>Design Evaluation: Building a physical and complex system is time-consuming and expensive. So we should determine whether a design works before building it rather than the other way round.</li>
				<li>Comparing Numerous Alternatives: Oftentimes there are a lot of possible strategies/methods to solve a problem/complete a task, we want to know which option is the best without trying all the possiblities.</li>
				<li>Emulate Dangerous or Impossible Situations: There are scenarios that are too dangerous to try (e.g. testing a war strategy, experimenting a possibly unstable chemical reactions, test safety systems in a nuclear reactor) or impossible to examine in real life (e.g. design a good defense for Quidditch). We need to construct a model to emulate this type of situations.</li>
				<li>Change Time Scales: On one hand, some events happen extremely fast (e.g. a car crash, a big bang). We want to slow them down to figure out what happened and why it happened during this entire event. On the other hand, some events happen relatively really slow (e.g. global warming, epidemics, extinction of endangered species). We would like to construct a model to see how things would go if the current situation persists (, which is kind of similar to the next reason).</li>
				<li>Predict the Future: We want to use the past experience to predict what is likely to happen in the future so we can prepare for it (e.g. weather forcasting) or make a profit (predicting stock prices, do high frequency trading based on price predictions a few milliseconds into the future).</li>
				<li>Cost Savings: It is very difficult to learn to fly aircrafts and newbies may make a lot of mistakes when learning, which may cause catastrophic outcomes. It is better we build a model aircraft and let newbies begin from there. Another example would be practice race driving. It may be costly to practice when prepping for a competition (e.g. Pikes Peak Internation Hill Climb, Formula One, WRC, etc) because you need to customize your race car often and it may not be possible to practice at the real course whenever you want. It is better we build a model, especially a simulation model so that we can not only practice but also try to see which customizations work before actually making the change.</li>
			</ol>

			<p>It sounds to me that modeling is good enough for problem solving already. Why do we want to blend in with simulation? Here are a few reasons why we would like to use simulation with modeling:</p>
			<ol>
				<li>Evaluate complex models: models are good when you are considering only a handful of objects, but if the number of objects increases and these objects can affect each other, then it becomes extremely difficult to compute the exact solution because you are actually not 100% what is going to happen and what the impact will be to subsequent events (e.g. Dumping a ball onto the ground vs. dumping a full bucket of balls onto the ground. When you dump a full bucket of balls onto the ground, balls may collide with each other, the change of directions may cause new colides.). Simulation will be very helpful here. Essentially we are trying to let everything happen to see how well the model is working intead of mathematically proving the model is working because the model is too complicated.</li>
				<li>Hypothese testing: there are cases where the real system may not be available, we would like to predict effects of the change we would like to make on the current system (e.g. changing workload, operating policies).</li>
				<li>Validate analytical models: Analytical models require many simplifying assumptions. We can use simulation to test how sensitive the results are to each of those assumptions.</li>
				<li>Control extraneous factors: Simluation is useful when you want to compare your models on the exact same situation and see how each of them works. An example is record the workload from one day in a hospital emergency ward and play it back exactly for each scheduling policies or job assignments you want to compare.</li>
			</ol>

			<p>Hmm... So we can use simulation to validate/test the model we created. Or we can build a simulation model to solve problems. But are there any drawbacks using simulation? There are and here they are:</p>
			<ol>
				<li>Simulation programs can be expensive, time-consuming to develop and run.</li>
				<li>Programs can be buggy.</li>
				<li>The simulation result is just an estimate. The solution it provides is not exact, meaning that it can change if you re-run the simulation although it may still fall into the pattern you find out. Not seeing something in your simulation does not mean that something cannot happen. It might be a black swan.</li>
			</ol>

			<p>After knowing the pros and cons about simulation. We can actually dive into simulation modeling and see what people have done using simulation. You may ask why we do not seem to care about using simulation to validate models. That answer is to validate the model via simulation, we are also constructing a simulation model, but catered to the problem of validating the math model we created.</p>

			<p>There are four types of simulation models if we consider the following two factors: (1)Are there factors of randomness? and (2)Is time a factor? Based on answers of the above questions we can categorize the model into:</p>
			<ol>
				<li>Deterministic-Static Simulation: no randomness, not time-variant. Example: floating-point arithmetic (used to simulate real number arithmetic on computing systems. Since they are finite they introduce errors. You need to make sure that floating-point arithmetics have the desire precision you want when using it); scale models (an example is scaling down the galaxy to a size that we can display it in a museum. Because the actual galaxy is too big for a museum so we created a simulated galaxy).</li>
				<li>Deterministic-Dynamic Simulation: no randomness, time-variant. Example: computational fluid dynamics; finite-element methods (use numerical methods to solve differential equations set, the answer simulates liquid, gas, or structures)</li>
				<li>Stochastic-Static Simluation: has randomness, not time-variant. Example: Monte Carlo methods (an example using this method is determing the probability of showing heads in a coin flip. We try flipping a coin for N times and record the number of appearance of heads H, then (H/N) will be the probability of the showing heads in a coin flip. The larger the N is, the more accurate the result will be).</li>
				<li>Stochastic-Dynamic Simulation: has randomness, time-variant. Example: Brownian motion; Discret-event stochastic models(random walk). This course will focus on discret-event stochastic models (think of it as a Marcov chain).</li>
			</ol>

			<p>An example: The Trained-Flea Experiment. A trained flea stands on a (2n+1) * (2n+1) chess board (this enviromnemt setting is called system). Initially he stands on the middle square (this is called the initial state). Each time a bell rings, he hops randomly to 1 to 8 adjacent cells (this is called an event). The problem is to find the average number of hops before he falls off the board (this is the experiment, or what we are going to find out using simulation). To simulate the problem is simple, one can write some code to generate a possible path and record the path length. Run this program multiple times and then you will get a estimate of the average path length.</p>

			<p>We can actually compare the math modeling and simulation modeling in this problem here by solving this problem. We can first solve a simpler version of this problem: The Trained-Flea Experiment on 3x3 chess board. Because the board is symmetric and that the flea's hopping action is memoryless, meaning that it can revisit a square, we can categorize the squares into three types: corner squares, mid-edge squares, and center. And then we solve this problem iteratively using dynamic programming. We can convert this problem to a finite horizon model with a simple "trick": suppose we ranout of food, so the flea will starve (to death) after his i-th hop. Thus, let a_i, b_i, c_i be the respective average of hops until he falls off the board (or dies) - starting from each square class. We can quickly derive that a_1 == b_1 == c_1 == 1 because the flea is on the board , so he needs at least one hop to fall of the board, and his food is only enough for him to make one hop only. When i is greater than 1, there are following conditions:</p>
			<ol>
				<li>If the flea is initially standing on a corner square, then a_i = (5/8) * 1 + (2/8) * (1+b_i-1) + (1/8) * (1+c_i-1) (i > 1)</li>
				<li>If the flea is initially standing on a mid-edge square, then b_i = (3/8) * 1 + (2/8) * (1+a_i-1) + (2/8) * (1+b_i-1) + (1/8) * (1+c_i-1)</li>
				<li>If the flea is initially standing on a center square, then c_i = (4/8) * (1+a_i-1) + (4/8) * (1+b_i-1)</li>
			</ol>

			<p>We can iterate these equations to eliminate the starvation "trick", the solution is the limit of c_i as i approaches positive infinity. When i approaches positive infinity, then i ~= i - 1, so we can throw away the subscripts and get the following three equations:</p>
			<ul>
				<li>a = (5/8) * 1 + (2/8) * (1+b) + (1/8) * (1+c)</li>
				<li>b = (3/8) * 1 + (2/8) * (1+a) + (2/8) * (1+b) + (1/8) * (1+c)</li>
				<li>c = (4/8) * (1+a) + (4/8) * (1+b)</li>
			</ul>
			<p>Solve the equations using Matlab is a = 2.0571, b = 2.5714, c = 3.3143. And we can expand the method to get a solution for a (2n+1) * (2n+1) chess board.</p>

			<p>Getting the exact solution is easier/faster/cheaper than writing a program to generate large numbers of sample paths. But if you want to add extra elements/restraints (e.g. a flew will not return to a visited square, a flew never choose the same direction twice in a row, or the board is not a square, or we have multiple fleas on the board, etc) to the model, it may be difficult to come up with a sleek solution like what we just did because we may not be able to apply the same techinque we used when a new constraint is added. But we are able to handle these changes when programming the simulation program. This actually gives an edge to the simulation model.</p>
		</div><br><br>

		<div class="w3-container w3-black">
			<h3>Lecture 2: Constructing a Model</h3>
			<p>Here are some steps we should take when constructing a simulation model:</p>
			<ol>
				<li>Formulate the problem and plan the study: figure out what you want to do with the simulation model you want to build (e.g. compare different alternatives, evaluate a strategy in a simulated environment);</li>
				<li>Collect data, define a model: here we need to follow the KISS principle: Keep It Simple Stupid;</li>
				<li>Test for validity: after coming up with a simulation model, we need to determine whether it captures the key features of the target system we want to simulate. We can do this by describing our model to domain experts, user, and other stake-holders;</li>
				<li>Construct the program and "verify" its correct operation: code your simulation model, and check: if your random number generator works correctly, if each random variable follows its chosen probability distribution, if each model component does what it supposed to, and if the "infrastructure" code in your model works fine;</li>
				<li>Make pilot runs and validate: make sure your simulation model works as expected. Test your model with boundary cases, test if your model can reproduce the behavior of an existing system with known parameter settings. If no, then go back to step 2 to collect more data snd refine the model. If yes, you can start your experiment;</li>
				<li>Design the experiment: there are a few things to keep in mind. You need to decide on an acceptable level of confidence in your conclusions. And you need to think about how to reduce variance in your models.</li>
				<li>Make production runs</li>
				<li>Analyze the outputs: we need to remember that each output is determined by a bunch of randoms numbers, which means that the result is just an estimate. We must provide confidence intervals for each output value.</li>
				<li>Document the process and implement the conclusions</li>
			</ol>

			<p>A simulation program should consist of the following components:</p>
			<ul>
				<li>System State: system state should include the following things:
						<ul>
							<li>Entities (customers, resources, etc): 
								<ul>
										<li>They have attributes such as location, arrival time, service demand. We can define an entity using struct or class in C++</li>
										<li>They may belong to groupings of similar entities (e.g. waiting lines). We can use a vector or list in C++ to capture such groupings.</li>
										<li>Different entity types may be related (e.g. server and customer). We may use pointers or a dictionary to store such mappings.</li>
								</ul>
							</li>
							<li>Stochastic variables: they are used to represent tntity attributes, event times, etc</li>
							<li>Strategies: they are used when comparing different versions of a model, represented by flag variables, separate functions</li>
						</ul>
				</li>
				<li>Simulation clock</li>
				<li>Events: an "atomic action" that updates the system states. Note that carrying out one event often triggers the creation of other events (e.g. each arrival event schedules the next arrival event, a start service event schedules the same customer's end serice event)</li>
				<li>Event Scheduling: scheduling determines how the system states in the model evolves over time. There are two ways to schedule events: time-driven and event-driven scheduling. As their names entail, time-driven scheduling loops through time and look for events that happen during each step, whereas event-driven scheduling loops uses a priority queue to store the events and go through them one by one, advancing time accordingly. Note that Time-driven scheduling is only useful when the timing of the events are roughly evenly spaced because if we choose a step that is too small we increase the program runtime by increasing the total number of iterations. If we choose a step that is too large we may end up artificially creating simultaneous sequential events which may not make sense.</li>
				<li>Program instrumentation: Data structures that record information about the simulation model. This is external to the actual model. Speaking of measurements, here are some of the items that you may be interested in tracking:
					<ul>
						<li>See if a specific events occur (dam bursts? hospital has no beds?)</li>
						<li>Count occurrences</li>
						<li>Find minimum or maximum valus</li>
						<li>Properties of attribute values (e.g. what fraction of customers wait longer 10 minutes; what is the 90th percentile of customer wait)</li>
					</ul>
				</li>
				<li>Report generator: you should have the same piece of code to produce "snap shots" during program execution, the code should be able to compute, tabulate and summarize the instrumentaion. The reason for "snap shots" is that we need to see the long-term trends of the output to find out if the system is actually behaving randomly.</li>
			</ul>

			<p>When doing measurements in a simulation model, there are two types of average we may need to compute: time average and population avarage. Time avarage is a weighted average with weight being the lifetime of a specific value. Whereas population average is a weighted average based on population. Here is a very interesting example about time-average and population-average:</p>
			<ul>
				<li>Suppose lightbulbs suffer from infant mortality problems.There is some kind of manufacturing defect that causes 75% of the lightbulbs to fail after 1000 hours; while the remaining 25% will last for 37000 hours before failure. The population average shows that the average lifetime for a lightbulb is 10000 hours. With population-average you may think that it is acceptable, but when you randomly pick a lightbulb, 75% percent you end up having a defected one. You actually need to buy at least eight lightbulbs at a time to guarantine a approx. 90% chance that you at least buy one normal lightbulb. How can I buy less lightbulbs but maintain the chance that I have a normal lightbulb?</li>
				<li>To do so, we need to use an extra equipment: the in-store lightbulb display that is used to demonstrate different style of lightbulb's color temperature and brightness. You should be able to find such display in Home Depot. The purchasing algorithm works as follows: 1) Find a box containing a new bulb of the desired style; 2) Swap the new bulb with the coresponding display sample; 3) Purchase the display sample and take it home. How does this in-store display help? We can demonstrate it using time-average.</li>
				<li>Suppose at time 0, a new sample is placed into the display. Once a sample is installed, its residual lifetime drops to zero at a slope of -1. Each burnt-out bulb is replaced immediately with a new sample so the lightbulb at the display is always on. Suppose I visit Home Depot at a random time, since a good bulb occupies 37 times as much time as a defective bulb, that means more likely the lightbulb at the display is a normal bulb. In fact, even though there are 3 times as much defective bulbs than normal bulbs, we still end up a probability of (0.25 * 37000) / (0.25 * 37000 + 0.75 * 1000) = 0.925. But because I come in at a random time, my display sample will be mid way through its life on average. The average residual lifetime for my display sample is: 0.075 * (1000/2) + 0.925 * (37000/2) = 17150 hours, much better than the expected average.</li>
				<li>A major drawback of this algorithm is that it only works for purchasing one bulb. If you want another bulb, then you may try going to another store, or wait 1000+ hours and return to the same store to try again (and hope nobody else tried your Purchasing Algorithm during that time).</li>
			</ul>

			<p>As for population average, there is one type of data we would like to know: the average number of customers in the system at any time. To get this number, one may need to do a scan over the each unit of time to compute the average. But there is a much quicker way to find out this number, if we know the average arrival rate of customers to the system and the average time in system for customers. This is Little's Law: average number of customers in the system = average time in system for customers * the average arrival rate of customers to the system.</p>

			<p>A concrete example is <a href="UCR-CS177_GasStationSimulationModel.cpp" target="_blank">the gas station example</a>.</p>
		</div><br><br>

		<div class="w3-container w3-bottom w3-black w3-center">
			<p>you can contact me via e-mail</p>
		</div>
	</body>
</html>
