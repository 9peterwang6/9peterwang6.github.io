<!DOCTYPE html>
<html>
	<head>
		<title>《集体智慧编程》中文版笔记</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="../w3.css">
	</head>

	<body>

		<!-- Header -->
		<div class="w3-container w3-black w3-center">
			<h1>《集体智慧编程》中文版笔记</h1>
		</div>

		<!-- Blog Content -->
		<div class="w3-container w3-black">
			<h3>第2章 提供推荐</h3>
			<p>本章的主要内容是讲如何为用户提供推荐。假设你拥有一个像豆瓣一样的点评类网站数据库，上面记录着不同的用户对不同的内容的评分，从中选出某一个用户和他的记录，如何给这位用户推荐他可能喜欢的内容呢？我们可以先从我们的生活经验出发去尝试解决这个问题。在生活中，我们有什么场景是想要寻求推荐的呢？买电脑、买书、看电影、吃饭等等。在这些场景中，我们会问什么人去获得推荐呢？第一类人是专家，在买电脑时我们可能会看各种博主测评，或者直接问自己认为比较懂电脑的亲朋好友同事。第二类人是用过这些产品的普通用户。</p>
			<p>当我们只考虑专家推荐时，我们会习惯于选择自己相信的专家然后听取他们的意见。在我们的问题中，假设我们能够知道数据库中哪些用户是专家用户，要想用这些专家数据提供推荐，我们还需要找出某一个用户最相信哪一位或者哪几位专家的意见。因为一个用户在听取了专家意见购买产品或者服务后，不一定会在网上反馈他的体验。另一方面，一个用户购买了某款产品的决定并不一定是听取了专家的意见。不过我们现在需要强行缩小考虑范围，方便我们探讨如何根据专家意见做推荐，因此我们需要先下一个强假设：用户的购买决定都是基于专家意见，建立出一个初步模型后再逐渐通过修改这个假设条件来优化我们的模型。在一开始，他可能并不相信任何一位专家，他只是随便看了看几个专家的测评就做决定了，如果说他不喜欢他买到的东西，那么他对产品的评分将会比较低，也不会再相信这位专家了。如果他喜欢买到的产品，他对产品的评分会比较高，他也会继续关注这位专家的测评。将这种情况放到我们的数据集里，我们就会发现我们和我们不喜欢的专家在同一样产品的评分上会有明显差异，而我们和我们喜欢的专家在同一样产品的评分上会比较接近。再抽象一点，我们可以用两点间距离来衡量我们对这些专家的信任程度：设某一普通用户和某一专家用户都评价了N个产品，普通用户对这些产品的评分为(x1, x2, ..., xN)，专家用户对应的评分为(y1, y2, ..., yN)。我们可以计算(x1, x2, ..., xN)和(y1, y2, ..., yN)的距离d=sqrt((x1 - y1)**2 + (x2 - y2)**2 + ... + (xN - yN)**2)。</p>
			<p>求出了距离之后，我们发现距离有大有小，距离越小代表信任程度越高。那我们能不能根据距离构造一个信任程度变量来直接衡量信任程度呢？我们可以令信任程度s=1/(1+d)，这样就得到了一个取值在(0,1]的信任程度变量，s越大信任程度越高。</p>
			<p>得到了信任程度后，我们可以挑选出最信任的（亦即s最大的）前k个专家，对该用户没有购买而这k个专家都购买了的每个产品，计算这个产品的推荐得分p=p1 * s1 + p2 * s2 + ... + pk * sk，其中p1, p2, ..., pk表示这些专家对这个产品的评分，s1, s2, ..., sk表示用户对这些专家的信任程度。将这个产品列表按p从高到低排序，就能得出我们给用户提供的推荐产品列表啦。</p>
			<p>如果我们只考虑普通用户的推荐时，我们同样可以采用像我们考虑专家推荐时的方法来给出一个推荐产品列表。因此，我们可以将所有人都视为专家，然后按照前文所述的方法给出一个推荐列表。这样的话，我们在只考虑专家意见时下的强假设，就可以减弱为：用户的购买决定都是基于其他用户的意见。这种方法有一个名字叫做协作型过滤。对于前文中提到的信任程度的计算，我们也可以考虑使用相关系数来代替，或者使用其他计算两点间距离的方式来进行模型性能提升。</p>
			<p>实际上信任程度的概念可以也引申出用户相似度的概念。用户相似度表示两个用户之间品味的相似程度。信任程度越高，购买方式越接近，相似度就越高。我们既然可以计算两个用户之间品味的相似程度，是否页可以计算两个产品之间的相似程度呢？设某一产品甲和另外一个产品乙都有相同的N个人进行了评价（也就是说这N个用户都评价了这两款产品），这N个用户给甲产品的评分为（x1, x2, ..., xN)，对乙产品的评分为(y1, y2, ..., yN)，我们可以计算这两组评分的距离d=sqrt((x1 - y1)**2 + (x2 - y2)**2 + ... + (xN - yN)**2)。距离越近，代表两个产品的相似程度越高。和前面一样，我们可以引入产品相似度的概念s=1/(1+d)。s越大两个产品相似程度越高。给定某一产品，我们就可以根据s选出k个与该产品最相似的其他产品用作推荐。我们可以用这种方式寻找相似的音乐，同类的书籍和电影等。我们也可以基于物品的相似程度以及用户的评分记录来给用户提供推荐。某个产品的推荐得分p=p1 * s1 + p2 * s2 + ... + pM * sM，其中M为我们评价的产品个数。对于某个产品以及某个用户，我们可以参考它和这个这个用户以往评价过的每个产品的相似度，通过计算加权平均的方式估算出一个可能的评分，将这些产品按照估算出的评分从高到低排列就可一得出我们给用户提供的推荐产品列表。</p>
			<p>在实际应用中，随着用户数量的增加，计算信任程度或用户相似度的开销将会越来越大，而且需要实时更新，这是因为我们总是要及时找到某个用户信任的用户是哪些人，而且我们需要在不同的用户上线的时候就要知道来给他们提供推荐，用户的评价记录更新较快，时常会出现新的信任程度高的用户，因此更新的频率较高。相对而言，产品相似度的结果会随着用户的增多而变得越来越稳定，因此我们只需要每隔一段长时间更新一次就可以得到一个较为准确且稳定的相似程度列表。这两种推荐方法在不同类型的产品中的效果会不一样，我们可以做一个AB测试来判断哪一个方式来判断哪一种方法更受用户喜欢。</p>
			<p>还有一种基于用户记录的推荐方法，是利用条件概率公式计算出在购买某一样产品甲后，会接着购买下一样产品乙的概率。这样在已知用户购买了产品甲后，可以给用户推荐用户大概率会接着购买的几个产品。我们也可以将这种高频率出现的购买组合打包成一个套餐，通过一个优惠的价格吸引更多的用户来购买这些产品。</p>
		</div><br><br>

		<!-- Footer -->
		<div class="w3-container w3-black w3-center">
			<p> you can contact me via e-mail</p>
		</div>

	</body>
</html>